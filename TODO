In vague order:

- Not sure about my global handling- do I need to do a load or not?
    Test this! (and fix Block.load_global as necessary)

- Add general recurion (let rec), functions only!

- Add support for floats

- Add support for strings

- Add variant types and simple 1-level pattern matching (case)

- Add complex pattern matching (match), get rid of let-tuple and case

- Switch from let-style to defn-style for global definitions

- Add type variables, polymorphic functions (half-mlton)

- Add support for large (> 32 elems) tuples.

- Add simple garbage collection (stop-the-world mark-sweep), shadow stack

- Add support for segmented (infinite) stacks.

- Add modules

- Add ml-style module-level functors

- Add type classes

- Add deferreds, remove non-monad mutation.

- GC only between deferreds- remove shadow stack.

- Add builtins (calling into native code)

- Add operator definitions, precedence handling, get rid of builtin operators

- Add pattern matching on operators

- Add where clause?

- Add rank-2 polymorphism

- Better GC (stop-the-word generational copying)

- Best GC (parallel & concurrent generational copying)

- Add repl

- Write stdlib

- Add STM

- Add lazy -- add let rec for lazy values.

- GADTs?

- Optimization: use aggregates for functions returning tuples?

- Optimization: Specialization?

- Optimization: Inlining/Loop conversion?

- Optimization: Constant propagation/dead code elimination?
                Do this before lambda lifting, so lambda expressions
                can be constant-propagated.

- Optimization: Pass the bound variables of a lifted lambda expression
                in as a tuple, rather than 1 by 1 (limits argument 
                number expansion)

- Optimization: Combine multiple allocs.  Consider doing let-flattening,
                so that:
                    let x =
                        let y = expr1 in
                        expr2
                    in
                    expr3
                becomes:
                    let y = expr1 in
                    let x = expr2 in
                    let _ = kill y in
                    expr3
                or even:
                    let y = expr1
                    and x = expr2
                    and _ = kill y
                    in
                    expr3

